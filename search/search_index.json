{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the C++ Code Wiki A collection of code examples for reference.","title":"Home"},{"location":"#welcome-to-the-c-code-wiki","text":"A collection of code examples for reference.","title":"Welcome to the C++ Code Wiki"},{"location":"io/","text":"Output hello-world.cpp #include <iostream> int main() { std::cout << \"Hello, World!\" << std::endl; return 0; } CMakeLists.txt cmake_minimum_required(VERSION 3.10) project(HelloWorld) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) add_executable(HelloWorld hello-world.cpp) Build cmake . cmake --build . Run ./HelloWorld","title":"Input & Output"},{"location":"io/#output","text":"hello-world.cpp #include <iostream> int main() { std::cout << \"Hello, World!\" << std::endl; return 0; } CMakeLists.txt cmake_minimum_required(VERSION 3.10) project(HelloWorld) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) add_executable(HelloWorld hello-world.cpp) Build cmake . cmake --build . Run ./HelloWorld","title":"Output"},{"location":"xwindow/xnextevent/","text":"XSendEvent main.cpp #include <stdio.h> #include <X11/Xlib.h> #include <X11/Xutil.h> #include <iostream> #include <iomanip> int main() { Display* display = XOpenDisplay(NULL); Window rootWindow = DefaultRootWindow(display); std::cout << \"Initialized\" << std::endl; // Enable KeyPress and KeyRelease events on the root window Window focusedWindow; int revertTo; XGetInputFocus(display, &focusedWindow, &revertTo); XSelectInput(display, focusedWindow, KeyPressMask | KeyReleaseMask); while(1) { XEvent event; XNextEvent(display, &event); if (event.type == KeyPress) { // Log the key press event // If you convert to hex you will notice that these are different from the hex keycodes and // states in /usr/include/X11/keysymdef.h // You need \"XLookupKeysym\"\" or \"XKeycodeToKeysym\" to convert them printf(\"Key Press: keycode=%u, state=%u\\n\", event.xkey.keycode, event.xkey.state); } else if (event.type == KeyRelease) { // Log the key release event printf(\"Key Release: keycode=%u, state=%u\\n\", event.xkey.keycode, event.xkey.state); } } XCloseDisplay(display); return 0; } CMakeLists.txt cmake_minimum_required(VERSION 3.10) project(xnextevent) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) find_package(X11 REQUIRED) INCLUDE_DIRECTORIES(${X11_INCLUDE_DIRS}) add_executable(xnextevent main.cpp) target_link_libraries(${PROJECT_NAME} ${X11_LIBRARIES})","title":"Next Event"},{"location":"xwindow/xnextevent/#xsendevent","text":"main.cpp #include <stdio.h> #include <X11/Xlib.h> #include <X11/Xutil.h> #include <iostream> #include <iomanip> int main() { Display* display = XOpenDisplay(NULL); Window rootWindow = DefaultRootWindow(display); std::cout << \"Initialized\" << std::endl; // Enable KeyPress and KeyRelease events on the root window Window focusedWindow; int revertTo; XGetInputFocus(display, &focusedWindow, &revertTo); XSelectInput(display, focusedWindow, KeyPressMask | KeyReleaseMask); while(1) { XEvent event; XNextEvent(display, &event); if (event.type == KeyPress) { // Log the key press event // If you convert to hex you will notice that these are different from the hex keycodes and // states in /usr/include/X11/keysymdef.h // You need \"XLookupKeysym\"\" or \"XKeycodeToKeysym\" to convert them printf(\"Key Press: keycode=%u, state=%u\\n\", event.xkey.keycode, event.xkey.state); } else if (event.type == KeyRelease) { // Log the key release event printf(\"Key Release: keycode=%u, state=%u\\n\", event.xkey.keycode, event.xkey.state); } } XCloseDisplay(display); return 0; } CMakeLists.txt cmake_minimum_required(VERSION 3.10) project(xnextevent) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) find_package(X11 REQUIRED) INCLUDE_DIRECTORIES(${X11_INCLUDE_DIRS}) add_executable(xnextevent main.cpp) target_link_libraries(${PROJECT_NAME} ${X11_LIBRARIES})","title":"XSendEvent"},{"location":"xwindow/xsendevent/","text":"XSendEvent main.cpp #include <X11/Xlib.h> #include <X11/keysym.h> #include <iostream> #include <unistd.h> #include <string.h> #include <map> using namespace std; std::map<const char*, KeyCode> keyMap { {\"\u00fc\", XK_udiaeresis}, {\"\u00dc\", XK_Udiaeresis}, {\"\u00f6\", XK_odiaeresis}, {\"\u00d6\", XK_Odiaeresis}, {\"\u00e4\", XK_adiaeresis}, {\"\u00c4\", XK_Adiaeresis}, {\"\u00df\", XK_ssharp}, {\"(\", XK_braceleft}, {\")\", XK_braceright}, {\"[\", XK_bracketleft}, {\"]\", XK_bracketright}, {\"<\", XK_greater}, {\">\", XK_less}, {\"{\", XK_braceleft}, {\"}\", XK_braceright} }; KeyCode stringToKeysym(const char* character) { if (keyMap.count(character) != 0) { return keyMap.at(character); } return XStringToKeysym(character); } void sendKeyEvent(Display* display, const char* character) { XEvent event; XKeyEvent keyEvent; Window focusedWindow; int revertTo; XGetInputFocus(display, &focusedWindow, &revertTo); // Set up the event structure event.xkey.type = KeyPress; event.xkey.window = focusedWindow; event.xkey.display = display; event.xkey.state = 0; KeyCode keycode; keycode = XKeysymToKeycode(display, stringToKeysym(character)); event.xkey.keycode = keycode; keyEvent = event.xkey; keyEvent.state = event.xkey.state; sleep(2); // Send the event XSendEvent(display, event.xkey.window, True, KeyPressMask, &event); XFlush(display); } int main() { Display* display = XOpenDisplay(NULL); if (display == NULL){ printf(\"Error: Unable to connect to X11\\n\"); return 1; } std::cout << \"Keysim for a : \" << (int)stringToKeysym(\"a\") << std::endl; std::cout << \"Keysim for { : \" << (int)stringToKeysym(\"{\") << std::endl; std::cout << \"Value of constant for { : \" << XK_braceleft << std::endl; sendKeyEvent(display, \"a\"); return 0; } code-state.cpp #include <X11/Xlib.h> #include <X11/keysym.h> #include <iostream> #include <unistd.h> #include <string.h> #include <map> using namespace std; // Code demonstrates raw keycode and state void sendKeyPressEvent(Display* display, int code, int state) { XEvent event; XKeyEvent keyEvent; Window focusedWindow; int revertTo; XGetInputFocus(display, &focusedWindow, &revertTo); // Set up the event structure event.xkey.type = KeyPress; event.xkey.window = focusedWindow; event.xkey.display = display; event.xkey.state = state; event.xkey.keycode = code; // Send the event XSendEvent(display, event.xkey.window, True, KeyPressMask, &event); XFlush(display); } void sendKeyReleaseEvent(Display* display, int code, int state) { XEvent event; XKeyEvent keyEvent; Window focusedWindow; int revertTo; XGetInputFocus(display, &focusedWindow, &revertTo); // Set up the event structure event.xkey.type = KeyPress; event.xkey.window = focusedWindow; event.xkey.display = display; event.xkey.state = state; event.xkey.keycode = code; // Send the event XSendEvent(display, event.xkey.window, True, KeyPressMask, &event); XFlush(display); } int main() { Display* display = XOpenDisplay(NULL); if (display == NULL){ printf(\"Error: Unable to connect to X11\\n\"); return 1; } sendKeyPressEvent(display, 44, 128); // Mod3 + n = ( return 0; } CMakeLists.txt cmake_minimum_required(VERSION 3.10) project(xsendevent) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) find_package(X11 REQUIRED) INCLUDE_DIRECTORIES(${X11_INCLUDE_DIRS}) add_executable(xsendevent main.cpp) target_link_libraries(${PROJECT_NAME} ${X11_LIBRARIES}) add_executable(codestate code-state.cpp) target_link_libraries(codestate ${X11_LIBRARIES})","title":"Send Event"},{"location":"xwindow/xsendevent/#xsendevent","text":"main.cpp #include <X11/Xlib.h> #include <X11/keysym.h> #include <iostream> #include <unistd.h> #include <string.h> #include <map> using namespace std; std::map<const char*, KeyCode> keyMap { {\"\u00fc\", XK_udiaeresis}, {\"\u00dc\", XK_Udiaeresis}, {\"\u00f6\", XK_odiaeresis}, {\"\u00d6\", XK_Odiaeresis}, {\"\u00e4\", XK_adiaeresis}, {\"\u00c4\", XK_Adiaeresis}, {\"\u00df\", XK_ssharp}, {\"(\", XK_braceleft}, {\")\", XK_braceright}, {\"[\", XK_bracketleft}, {\"]\", XK_bracketright}, {\"<\", XK_greater}, {\">\", XK_less}, {\"{\", XK_braceleft}, {\"}\", XK_braceright} }; KeyCode stringToKeysym(const char* character) { if (keyMap.count(character) != 0) { return keyMap.at(character); } return XStringToKeysym(character); } void sendKeyEvent(Display* display, const char* character) { XEvent event; XKeyEvent keyEvent; Window focusedWindow; int revertTo; XGetInputFocus(display, &focusedWindow, &revertTo); // Set up the event structure event.xkey.type = KeyPress; event.xkey.window = focusedWindow; event.xkey.display = display; event.xkey.state = 0; KeyCode keycode; keycode = XKeysymToKeycode(display, stringToKeysym(character)); event.xkey.keycode = keycode; keyEvent = event.xkey; keyEvent.state = event.xkey.state; sleep(2); // Send the event XSendEvent(display, event.xkey.window, True, KeyPressMask, &event); XFlush(display); } int main() { Display* display = XOpenDisplay(NULL); if (display == NULL){ printf(\"Error: Unable to connect to X11\\n\"); return 1; } std::cout << \"Keysim for a : \" << (int)stringToKeysym(\"a\") << std::endl; std::cout << \"Keysim for { : \" << (int)stringToKeysym(\"{\") << std::endl; std::cout << \"Value of constant for { : \" << XK_braceleft << std::endl; sendKeyEvent(display, \"a\"); return 0; } code-state.cpp #include <X11/Xlib.h> #include <X11/keysym.h> #include <iostream> #include <unistd.h> #include <string.h> #include <map> using namespace std; // Code demonstrates raw keycode and state void sendKeyPressEvent(Display* display, int code, int state) { XEvent event; XKeyEvent keyEvent; Window focusedWindow; int revertTo; XGetInputFocus(display, &focusedWindow, &revertTo); // Set up the event structure event.xkey.type = KeyPress; event.xkey.window = focusedWindow; event.xkey.display = display; event.xkey.state = state; event.xkey.keycode = code; // Send the event XSendEvent(display, event.xkey.window, True, KeyPressMask, &event); XFlush(display); } void sendKeyReleaseEvent(Display* display, int code, int state) { XEvent event; XKeyEvent keyEvent; Window focusedWindow; int revertTo; XGetInputFocus(display, &focusedWindow, &revertTo); // Set up the event structure event.xkey.type = KeyPress; event.xkey.window = focusedWindow; event.xkey.display = display; event.xkey.state = state; event.xkey.keycode = code; // Send the event XSendEvent(display, event.xkey.window, True, KeyPressMask, &event); XFlush(display); } int main() { Display* display = XOpenDisplay(NULL); if (display == NULL){ printf(\"Error: Unable to connect to X11\\n\"); return 1; } sendKeyPressEvent(display, 44, 128); // Mod3 + n = ( return 0; } CMakeLists.txt cmake_minimum_required(VERSION 3.10) project(xsendevent) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) find_package(X11 REQUIRED) INCLUDE_DIRECTORIES(${X11_INCLUDE_DIRS}) add_executable(xsendevent main.cpp) target_link_libraries(${PROJECT_NAME} ${X11_LIBRARIES}) add_executable(codestate code-state.cpp) target_link_libraries(codestate ${X11_LIBRARIES})","title":"XSendEvent"}]}